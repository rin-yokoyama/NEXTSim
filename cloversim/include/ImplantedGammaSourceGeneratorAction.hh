// ImplantedGammaSourceGeneratorAction.hh generated by R. Yokoyama on 1/29/2020

#ifndef INMPLANTED_GAMMA_SOURCE_GENERATOR_ACTION_HH
#define INMPLANTED_GAMMA_SOURCE_GENERATOR_ACTION_HH

#include "G4VUserPrimaryGeneratorAction.hh"
#include "G4ParticleGun.hh"
#include "G4ParticleTable.hh"
#include "G4Event.hh"
#include "G4ThreeVector.hh"
#include "G4RandomTools.hh"
#include "PointGammaSourceGeneratorAction.hh"
#include <TDirectory.h>
#include <TChain.h>
#include <TTreeReader.h>
#include <TTreeReaderValue.h>
#include <TFile.h>
#include <TParameter.h>
#include <TROOT.h>
#include <TSystem.h>
#include <TMath.h>

// This is an abstract base class for PrimaryGeneratorAction using an actual implantation
// profile from experimental ROOT files. 
// The virtual method ReadPosition() must be overrided in a derrived class.
// class T is the type of data filled in the Branch of the input TTree.
template <class T>
class ImplantedGammaSourceGeneratorAction : public PointGammaSourceGeneratorAction {
	
public:
	ImplantedGammaSourceGeneratorAction();
	virtual ~ImplantedGammaSourceGeneratorAction();

	int Configure();
	void GeneratePrimaries(G4Event *anEvent);

	virtual void SetReader() { std::cout << "virtual SetReader() called." << std::endl; };
	virtual const G4ThreeVector ReadPosition() { return G4ThreeVector(0,0,0); }
	virtual bool IsInside(const Double_t &x, const Double_t &y) const {
		return (radA_ * TMath::Power(x - x0_, 2) + radB_ * TMath::Power(y - y0_, 2) < 1);
	}

    void SetGeneratorName(const G4String &name) {generator_name_ = name;}
    void SetTreeName(const G4String &name) {tree_name_ = name;}
    void SetBranchName(const G4String &name) {branch_name_ = name;}
    void AddFile(const G4String &name) {merger_list_.emplace_back(name);}
	virtual bool Next();

protected:
	TChain* input_tree_ = nullptr;

	TTreeReader* tree_reader_ = nullptr;
	TTreeReaderValue<T>* reader_value_ = nullptr;
	std::string branch_name_;
	TParameter<Bool_t>* ret_val_ = nullptr;

	Bool_t pid_gate_ = false;
	Double_t radA_;
	Double_t radB_;
	Double_t x0_;
	Double_t y0_;

    G4String generator_name_;
    G4String tree_name_;
    std::vector<G4String> merger_list_;

};

template <class T>
ImplantedGammaSourceGeneratorAction<T>::ImplantedGammaSourceGeneratorAction() :
generator_name_("point")
{
}

template <class T>
ImplantedGammaSourceGeneratorAction<T>::~ImplantedGammaSourceGeneratorAction() {
	if (input_tree_)
		delete input_tree_;
	if (particle_gun_)
		delete particle_gun_;
}

template <class T>
int ImplantedGammaSourceGeneratorAction<T>::Configure() {

	std::cout << "[ImplantedGammaSourceGeneratorAction]: Generator name: "
		<< generator_name_ << std::endl;
	/* if generator is a point gamma source */
    if (generator_name_ == "point")
        return PointGammaSourceGeneratorAction::Configure();

	gSystem->Load("libyaml-cpp.so");
	gSystem->Load("libmerger_data_dic.so");
	gSystem->Load("libTraceAnalyzerLib.so");
	gSystem->Load("libMergerLib.so");
	gSystem->Load("libCorrectionLib.so");

    /* other wise, implanted source */

    PointGammaSourceGeneratorAction::Configure();

	if (input_tree_)
		delete input_tree_;
	{
		//std::string cmd = "TChain* chain = new TChain(\"" + tree_name_ + "\");";
		//gROOT->ProcessLine(cmd.c_str());
		input_tree_ = new TChain(tree_name_.c_str());
	}
	/* adds all rootfiles in the list to the TChain object */
	for (const auto& file_name : merger_list_) {
		//std::string cmd = "chain->Add(\"" + file_name + "\");";
		//gROOT->ProcessLine(cmd.c_str());
		input_tree_->Add(file_name.c_str());
		std::cout << "[ImplantedGammaSourceGeneratorAction]: Adding file to chain: " << file_name << std::endl;
	}
	//gROOT->ProcessLine("gROOT->Append(chain);");
	//input_tree_ = (TChain*)gDirectory->GetList()->At(0);
	//input_tree_ = (TChain*)gDirectory->FindObject(tree_name_.c_str());
	std::cout << "[ImplantedGammaSourceGeneratorAction]: Number of files added to the chain: " << input_tree_->GetNtrees() << std::endl;

	/* sets TTree Reader */
	if (tree_reader_)
		delete tree_reader_;
	//gROOT->ProcessLine("auto reader = new TTreeReader(chain);");
	//gROOT->ProcessLine("gROOT->Append(reader);");
	//gDirectory->GetList()->Print();
	//tree_reader_ = (TTreeReader*)gDirectory->GetList()->At(1);
	tree_reader_ = new TTreeReader(input_tree_);
	if (!tree_reader_)
		std::cout << "[ImplantedGammaSourceGeneratorAction]: Null pointer to the TTreeReader" << std::endl;
	//gROOT->ProcessLine("auto param = new TParameter<Bool_t>(\"ReturnVal\",false);");
	//gROOT->ProcessLine("gROOT->Append(param);");
	//ret_val_ = (TParameter<Bool_t>*)gDirectory->FindObject("ReturnVal");

	if (reader_value_)
		delete reader_value_;
	reader_value_ = new TTreeReaderValue<T>(*tree_reader_,branch_name_.c_str());
	//this->SetReader();

	return 0;
}

template <class T>
bool ImplantedGammaSourceGeneratorAction<T>::Next() {
	/* reads the next entry of the tree */
	/* if the file ends, restart from the first entry */
	if (!tree_reader_) {
		std::cout << "[ImplantedGammaSourceGeneratorAction]: TTree reader is not configured." << std::endl;
		return false;
	}
	auto read_next = [&]()->bool { return tree_reader_->Next();};
	if (!read_next()) {
		tree_reader_->Restart();
		if (!read_next()) {
			std::cout << "[ImplantedGammaSourceGeneratorAction]: failed to read events from tree." << std::endl;
			return false;
		}
	}
	return true;
}

template <class T>
void ImplantedGammaSourceGeneratorAction<T>::GeneratePrimaries( G4Event* anEvent ) {

	/* if point source */
	if (generator_name_ == "point"){
		PointGammaSourceGeneratorAction::GeneratePrimaries(anEvent);
		return;
	}

	/* isotropic direction generator */
	auto moment_dir = []() {
		/* A=-1, B=1 for 4*pi, B=0 for 2*pi emission */
		const G4double A = -1.0;
		const G4double B = 1.0;
		G4double cosTheta = G4UniformRand() * (B - A) + A;	 // A < cosTheta < B
		G4double sinTheta = sqrt(1.0 - cosTheta * cosTheta); // 0. < sinTheta < 1.
		G4double phi = G4UniformRand() * 8.0 * atan(1.0);	 // 0. <		particle_gun_->GeneratePrimaryVertex(anEvent); phi < 2*pi

		G4double randomXaim = cos(phi) * sinTheta;
		G4double randomYaim = sin(phi) * sinTheta;
		G4double randomZaim = cosTheta;
		G4ThreeVector aim(randomXaim, randomYaim, randomZaim);
		return aim;
	};

	/* Set particle position */
	particle_gun_->SetParticlePosition(this->ReadPosition());

	/* No source file provided */
	if (!gamma_source_) {
		particle_gun_->SetParticleEnergy(energy_);
		particle_gun_->SetParticleMomentumDirection(moment_dir());
		particle_gun_->GeneratePrimaryVertex(anEvent);
		return;
	}

	/* set gamma-ray energy*/
	if (!gamma_source_->IfNext()) {
		particle_gun_->SetParticleEnergy(0.);
		if (!completed_) {
			std::cout << "[PointGammaSourceGeneratorAction]: gamma emission completed." << std::endl;
			completed_ = true;
		}
		return;
	}

	G4int n_gamma = gamma_source_->EmitGamma();
	for (int i = 0; i < n_gamma; ++i)
	{
		/* set gamma-ray direction */
		{
			particle_gun_->SetParticleMomentumDirection(moment_dir());
		}
		particle_gun_->SetParticleEnergy(gamma_source_->GetEGamma(i) * CLHEP::keV);
		particle_gun_->GeneratePrimaryVertex(anEvent);
	}
	
	return;
}
#endif
